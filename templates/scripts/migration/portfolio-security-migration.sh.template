#!/usr/bin/env bash
# =============================================================================
# AI Infrastructure Portfolio Security Migration
# =============================================================================
# Main orchestrator script for transforming project into portfolio-ready state
# with enterprise security practices and 1Password integration.
#
# Features:
# - Progress tracking with persistent state
# - Safe migration with verification steps
# - Resume capability from any step
# - Color-coded status indicators
# - Interactive confirmations for destructive operations
#
# Usage:
#   ./scripts/portfolio-security-migration.sh          # Start from beginning
#   ./scripts/portfolio-security-migration.sh --resume # Resume from last step
#   ./scripts/portfolio-security-migration.sh --verify # Verify current state
#   ./scripts/portfolio-security-migration.sh --help   # Show this help
# =============================================================================

set -euo pipefail

# Script configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"
STATE_FILE="$PROJECT_ROOT/.migration-state"
BACKUP_DIR="$PROJECT_ROOT/backup/pre-migration-$(date +%Y%m%d-%H%M%S)"
LOG_FILE="$PROJECT_ROOT/logs/migration-$(date +%Y%m%d-%H%M%S).log"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
WHITE='\033[1;37m'
NC='\033[0m' # No Color

# Status indicators
COMPLETE="✓"
IN_PROGRESS="⚡"
WARNING="⚠"
PENDING="⏳"
FAILED="✗"
SKIPPED="↪"

# Migration steps configuration
declare -a MIGRATION_STEPS=(
    "pre_flight_checks:Pre-flight checks and setup"
    "create_backup:Create full project backup"
    "inventory_secrets:Inventory current secrets and files"
    "setup_1password:Setup 1Password vault structure"
    "store_ssl_certs:Store SSL certificates in 1Password"
    "store_config_secrets:Store configuration secrets"
    "store_user_data:Store user databases and auth data"
    "verify_1password_storage:Verify all data in 1Password"
    "create_templates:Create secure configuration templates"
    "sanitize_configs:Remove personal info and use placeholders"
    "update_scripts:Update scripts for 1Password integration"
    "remove_sensitive_files:Remove sensitive files from filesystem"
    "update_documentation:Update docs for portfolio presentation"
    "final_verification:Final security verification"
)

# Initialize logging
mkdir -p "$(dirname "$LOG_FILE")"
exec 1> >(tee -a "$LOG_FILE")
exec 2> >(tee -a "$LOG_FILE" >&2)

# =============================================================================
# UTILITY FUNCTIONS
# =============================================================================

log() {
    echo -e "[$(date '+%Y-%m-%d %H:%M:%S')] $*" | tee -a "$LOG_FILE"
}

log_info() {
    log "${BLUE}[INFO]${NC} $*"
}

log_success() {
    log "${GREEN}[SUCCESS]${NC} $*"
}

log_warning() {
    log "${YELLOW}[WARNING]${NC} $*"
}

log_error() {
    log "${RED}[ERROR]${NC} $*"
}

log_step() {
    log "${PURPLE}[STEP]${NC} $*"
}

show_help() {
    cat << EOF
${WHITE}AI Infrastructure Portfolio Security Migration${NC}

Transform your AI infrastructure project into a portfolio-ready showcase
with enterprise security practices and complete 1Password integration.

${WHITE}USAGE:${NC}
    $(basename "$0") [OPTIONS]

${WHITE}OPTIONS:${NC}
    --resume        Resume from the last incomplete step
    --verify        Verify current migration state without making changes
    --step <name>   Start from specific step (use --list-steps to see options)
    --list-steps    Show all available steps
    --dry-run       Show what would be done without executing
    --help          Show this help message

${WHITE}EXAMPLES:${NC}
    $(basename "$0")                    # Start fresh migration
    $(basename "$0") --resume           # Resume from where you left off
    $(basename "$0") --verify           # Check current state
    $(basename "$0") --step store_ssl_certs # Start from SSL certificate step

${WHITE}MIGRATION OVERVIEW:${NC}
This script will safely transform your project by:
1. Backing up all current data
2. Storing secrets in 1Password (66 SSL certs, configs, databases)
3. Creating secure templates with op:// references
4. Removing personal information
5. Cleaning sensitive files from filesystem
6. Updating documentation for portfolio presentation

${WHITE}SAFETY FEATURES:${NC}
- Full backup before any changes
- Verification before destructive operations
- Progress tracking and resume capability
- Interactive confirmations
- Detailed logging

EOF
}

list_steps() {
    echo -e "${WHITE}Available Migration Steps:${NC}"
    for i in "${!MIGRATION_STEPS[@]}"; do
        local step_def="${MIGRATION_STEPS[$i]}"
        local step_name="${step_def%%:*}"
        local step_desc="${step_def##*:}"
        printf "%2d. %-25s %s\n" $((i+1)) "$step_name" "$step_desc"
    done
}

get_step_status() {
    local step_name="$1"
    if [[ -f "$STATE_FILE" ]]; then
        grep -q "^$step_name:completed" "$STATE_FILE" 2>/dev/null && echo "completed" && return
        grep -q "^$step_name:failed" "$STATE_FILE" 2>/dev/null && echo "failed" && return
        grep -q "^$step_name:in_progress" "$STATE_FILE" 2>/dev/null && echo "in_progress" && return
    fi
    echo "pending"
}

set_step_status() {
    local step_name="$1"
    local status="$2"
    
    # Remove any existing status for this step
    if [[ -f "$STATE_FILE" ]]; then
        grep -v "^$step_name:" "$STATE_FILE" > "${STATE_FILE}.tmp" 2>/dev/null || true
        mv "${STATE_FILE}.tmp" "$STATE_FILE" 2>/dev/null || true
    fi
    
    # Add new status
    echo "$step_name:$status:$(date '+%Y-%m-%d %H:%M:%S')" >> "$STATE_FILE"
}

show_progress() {
    echo -e "\n${WHITE}=== MIGRATION PROGRESS ===${NC}"
    
    for i in "${!MIGRATION_STEPS[@]}"; do
        local step_def="${MIGRATION_STEPS[$i]}"
        local step_name="${step_def%%:*}"
        local step_desc="${step_def##*:}"
        local status=$(get_step_status "$step_name")
        
        local indicator=""
        local color=""
        
        case "$status" in
            "completed") indicator="$COMPLETE" color="$GREEN" ;;
            "in_progress") indicator="$IN_PROGRESS" color="$YELLOW" ;;
            "failed") indicator="$FAILED" color="$RED" ;;
            *) indicator="$PENDING" color="$NC" ;;
        esac
        
        printf "[%s%s%s] %-2d. %-25s %s\n" "$color" "$indicator" "$NC" $((i+1)) "$step_name" "$step_desc"
    done
    echo
}

confirm_action() {
    local message="$1"
    local default="${2:-n}"
    
    while true; do
        if [[ "$default" == "y" ]]; then
            read -p "$message (Y/n): " response
            response=${response:-y}
        else
            read -p "$message (y/N): " response
            response=${response:-n}
        fi
        
        case "$response" in
            [Yy]|[Yy][Ee][Ss]) return 0 ;;
            [Nn]|[Nn][Oo]) return 1 ;;
            *) echo "Please answer yes or no." ;;
        esac
    done
}

find_resume_step() {
    local last_completed=""
    local next_step=""
    
    for step_def in "${MIGRATION_STEPS[@]}"; do
        local step_name="${step_def%%:*}"
        local status=$(get_step_status "$step_name")
        
        if [[ "$status" == "completed" ]]; then
            last_completed="$step_name"
        elif [[ "$status" == "in_progress" || "$status" == "failed" ]]; then
            echo "$step_name"
            return 0
        elif [[ -n "$last_completed" && "$status" == "pending" ]]; then
            echo "$step_name"
            return 0
        fi
    done
    
    # If we get here, either nothing is started or everything is done
    if [[ -z "$last_completed" ]]; then
        echo "${MIGRATION_STEPS[0]%%:*}"  # First step
    else
        echo "completed"  # All done
    fi
}

# =============================================================================
# MIGRATION STEP IMPLEMENTATIONS
# =============================================================================

step_pre_flight_checks() {
    log_step "Running pre-flight checks"
    set_step_status "pre_flight_checks" "in_progress"
    
    # Check 1Password CLI
    if ! command -v op >/dev/null 2>&1; then
        log_error "1Password CLI not found. Install from: https://1password.com/downloads/command-line/"
        set_step_status "pre_flight_checks" "failed"
        return 1
    fi
    
    # Check 1Password authentication
    if ! op account list >/dev/null 2>&1; then
        log_error "1Password CLI not signed in. Run: op signin"
        set_step_status "pre_flight_checks" "failed"
        return 1
    fi
    
    # Check git status
    if [[ -d "$PROJECT_ROOT/.git" ]]; then
        cd "$PROJECT_ROOT"
        if ! git diff --quiet || ! git diff --cached --quiet; then
            log_warning "Git working directory has uncommitted changes"
            if ! confirm_action "Continue with uncommitted changes?"; then
                set_step_status "pre_flight_checks" "failed"
                return 1
            fi
        fi
    fi
    
    # Check required directories
    mkdir -p "$PROJECT_ROOT/logs"
    mkdir -p "$PROJECT_ROOT/backup"
    
    log_success "Pre-flight checks completed"
    set_step_status "pre_flight_checks" "completed"
}

step_create_backup() {
    log_step "Creating full project backup"
    set_step_status "create_backup" "in_progress"
    
    mkdir -p "$BACKUP_DIR"
    
    # Backup entire project
    log_info "Backing up project to: $BACKUP_DIR"
    rsync -av --progress "$PROJECT_ROOT/" "$BACKUP_DIR/" \
        --exclude='.git' \
        --exclude='backup/' \
        --exclude='logs/' \
        --exclude='node_modules/' \
        --exclude='__pycache__/' \
        --exclude='.DS_Store'
    
    # Create inventory of sensitive files
    log_info "Creating inventory of sensitive files"
    find "$PROJECT_ROOT" \( -name "*.key" -o -name "*.crt" -o -name "*.pem" \
                          -o -name "*.sqlite*" -o -name "notification.txt" \
                          -o -name "users_database.yml" \) \
                          -not -path "*/backup/*" \
                          -not -path "*/.git/*" > "$BACKUP_DIR/sensitive-files-inventory.txt"
    
    local file_count=$(wc -l < "$BACKUP_DIR/sensitive-files-inventory.txt")
    log_info "Found $file_count sensitive files to migrate"
    
    log_success "Backup created: $BACKUP_DIR"
    set_step_status "create_backup" "completed"
}

step_inventory_secrets() {
    log_step "Inventorying current secrets and configuration"
    set_step_status "inventory_secrets" "in_progress"
    
    local inventory_file="$PROJECT_ROOT/backup/secrets-inventory-$(date +%Y%m%d-%H%M%S).json"
    
    cat > "$inventory_file" << EOF
{
    "migration_date": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
    "ssl_certificates": {
        "count": $(find "$PROJECT_ROOT" -name "*.crt" -not -path "*/backup/*" | wc -l),
        "files": [
$(find "$PROJECT_ROOT" -name "*.crt" -not -path "*/backup/*" | sed 's/.*/"&"/' | paste -sd, -)
        ]
    },
    "private_keys": {
        "count": $(find "$PROJECT_ROOT" -name "*.key" -not -path "*/backup/*" | wc -l),
        "files": [
$(find "$PROJECT_ROOT" -name "*.key" -not -path "*/backup/*" | sed 's/.*/"&"/' | paste -sd, -)
        ]
    },
    "databases": {
        "count": $(find "$PROJECT_ROOT" -name "*.sqlite*" -not -path "*/backup/*" | wc -l),
        "files": [
$(find "$PROJECT_ROOT" -name "*.sqlite*" -not -path "*/backup/*" | sed 's/.*/"&"/' | paste -sd, -)
        ]
    },
    "config_secrets": [
        "AUTHELIA_SESSION_SECRET",
        "AUTHELIA_STORAGE_ENCRYPTION_KEY",
        "WEBUI_SECRET_KEY",
        "USER_PREFIX"
    ],
    "personal_info_locations": [
        ".env",
        "services/auth/configs/users_database.yml",
        "services/nginx/configs/https.conf",
        "services/auth/configs/configuration.yml"
    ]
}
EOF
    
    log_info "Secrets inventory saved to: $inventory_file"
    log_success "Inventory completed"
    set_step_status "inventory_secrets" "completed"
}

# Source additional step implementations
if [[ -f "$SCRIPT_DIR/migration-steps.sh" ]]; then
    source "$SCRIPT_DIR/migration-steps.sh"
else
    log_warning "Additional migration steps not found: $SCRIPT_DIR/migration-steps.sh"
fi

# =============================================================================
# MAIN EXECUTION
# =============================================================================

main() {
    local resume_mode=false
    local verify_mode=false
    local dry_run=false
    local start_step=""
    
    # Parse command line arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --resume)
                resume_mode=true
                shift
                ;;
            --verify)
                verify_mode=true
                shift
                ;;
            --dry-run)
                dry_run=true
                shift
                ;;
            --step)
                start_step="$2"
                shift 2
                ;;
            --list-steps)
                list_steps
                exit 0
                ;;
            --help)
                show_help
                exit 0
                ;;
            *)
                echo "Unknown option: $1"
                show_help
                exit 1
                ;;
        esac
    done
    
    # Show header
    echo -e "${WHITE}"
    echo "================================================================================================="
    echo "                          AI INFRASTRUCTURE PORTFOLIO SECURITY MIGRATION"
    echo "================================================================================================="
    echo -e "${NC}"
    
    # Show current progress
    show_progress
    
    if [[ "$verify_mode" == true ]]; then
        log_info "Verification mode - no changes will be made"
        exit 0
    fi
    
    # Determine starting step
    if [[ "$resume_mode" == true ]]; then
        start_step=$(find_resume_step)
        if [[ "$start_step" == "completed" ]]; then
            log_success "All migration steps completed!"
            exit 0
        fi
        log_info "Resuming from step: $start_step"
    elif [[ -z "$start_step" ]]; then
        start_step="${MIGRATION_STEPS[0]%%:*}"
    fi
    
    # Execute migration steps
    local start_executing=false
    for step_def in "${MIGRATION_STEPS[@]}"; do
        local step_name="${step_def%%:*}"
        local step_desc="${step_def##*:}"
        
        if [[ "$step_name" == "$start_step" ]]; then
            start_executing=true
        fi
        
        if [[ "$start_executing" == false ]]; then
            continue
        fi
        
        local status=$(get_step_status "$step_name")
        if [[ "$status" == "completed" ]]; then
            log_info "Skipping completed step: $step_name"
            continue
        fi
        
        echo -e "\n${CYAN}==== EXECUTING: $step_desc ====${NC}"
        
        if [[ "$dry_run" == true ]]; then
            log_info "[DRY RUN] Would execute: $step_name"
            continue
        fi
        
        # Execute the step function
        if declare -f "step_$step_name" >/dev/null; then
            if ! "step_$step_name"; then
                log_error "Step failed: $step_name"
                show_progress
                exit 1
            fi
        else
            log_warning "Step implementation not found: step_$step_name"
            set_step_status "$step_name" "completed"
        fi
        
        show_progress
        echo
    done
    
    log_success "Migration completed successfully!"
    show_progress
}

# Run main function if script is executed directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi