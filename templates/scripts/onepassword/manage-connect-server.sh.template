#!/bin/bash

# manage-connect-server.sh
# Management script for 1Password Connect Server
# Provides start/stop/status/health operations for self-hosted secret management

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"
CONNECT_COMPOSE_FILE="$PROJECT_ROOT/services/onepassword/docker-compose.yml"
CREDENTIALS_FILE="$PROJECT_ROOT/services/onepassword/1password-credentials.json"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
NC='\033[0m' # No Color

log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

log_debug() {
    echo -e "${PURPLE}[DEBUG]${NC} $1"
}

show_usage() {
    cat << EOF
Usage: $0 <command> [options]

COMMANDS:
    start               Start 1Password Connect Server
    stop                Stop 1Password Connect Server
    restart             Restart 1Password Connect Server
    status              Show Connect Server status
    health              Perform health checks
    logs                Show Connect Server logs
    token               Generate or manage access tokens
    test                Test API connectivity
    cleanup             Remove Connect Server containers and data

OPTIONS:
    -f, --follow        Follow logs in real-time
    -q, --quiet         Suppress non-essential output
    -h, --help          Show this help message

EXAMPLES:
    $0 start                    # Start Connect Server
    $0 logs --follow           # Follow logs in real-time
    $0 health                  # Check server health
    $0 token create            # Create new access token
    $0 test                    # Test API connectivity

REQUIREMENTS:
    - 1password-credentials.json file in services/onepassword/ directory
    - Docker and Docker Compose installed
    - 1Password CLI (op) for token management

EOF
}

check_prerequisites() {
    # Check for credentials file
    if [[ ! -f "$CREDENTIALS_FILE" ]]; then
        log_error "Missing 1Password credentials file: $CREDENTIALS_FILE"
        log_info "Generate credentials with: op connect server create \"Athena Core Connect Server\" --vaults \"API,Elevenlabs Voice IDs,SSL,Webhooks\""
        log_info "The credentials file should be located at: services/onepassword/1password-credentials.json"
        exit 1
    fi

    # Check for Docker Compose
    if ! command -v docker &> /dev/null; then
        log_error "Docker is not installed or not in PATH"
        exit 1
    fi

    # Check credentials file permissions (should be restrictive)
    local perms=$(stat -f "%OLp" "$CREDENTIALS_FILE" 2>/dev/null || stat -c "%a" "$CREDENTIALS_FILE" 2>/dev/null)
    if [[ "$perms" != "600" ]]; then
        log_warning "Credentials file permissions are not secure (current: $perms)"
        log_info "Setting secure permissions (600)..."
        chmod 600 "$CREDENTIALS_FILE"
    fi
}

start_connect_server() {
    log_info "üöÄ Starting 1Password Connect Server..."
    
    cd "$PROJECT_ROOT"
    
    if docker compose -f "$CONNECT_COMPOSE_FILE" up -d; then
        log_success "Connect Server containers started"
        
        # Wait for health checks
        log_info "Waiting for services to be healthy..."
        local max_wait=60
        local wait_time=0
        
        while [[ $wait_time -lt $max_wait ]]; do
            if health_check --quiet; then
                log_success "Connect Server is healthy and ready!"
                return 0
            fi
            sleep 5
            wait_time=$((wait_time + 5))
            echo -n "."
        done
        
        log_warning "Connect Server started but health checks are not passing"
        log_info "Check logs with: $0 logs"
    else
        log_error "Failed to start Connect Server"
        exit 1
    fi
}

stop_connect_server() {
    log_info "üõë Stopping 1Password Connect Server..."
    
    cd "$PROJECT_ROOT"
    
    if docker compose -f "$CONNECT_COMPOSE_FILE" down; then
        log_success "Connect Server stopped"
    else
        log_error "Failed to stop Connect Server"
        exit 1
    fi
}

restart_connect_server() {
    log_info "üîÑ Restarting 1Password Connect Server..."
    stop_connect_server
    sleep 2
    start_connect_server
}

show_status() {
    log_info "üìä 1Password Connect Server Status:"
    echo ""
    
    cd "$PROJECT_ROOT"
    
    # Show container status
    if docker compose -f "$CONNECT_COMPOSE_FILE" ps --format "table {{.Name}}\t{{.Status}}\t{{.Ports}}"; then
        echo ""
        
        # Show network information
        log_info "üåê Network Configuration:"
        local api_container=$(docker compose -f "$CONNECT_COMPOSE_FILE" ps -q onepassword-connect-api 2>/dev/null || true)
        if [[ -n "$api_container" ]]; then
            local ip=$(docker inspect "$api_container" --format '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' 2>/dev/null || echo "N/A")
            log_info "  API Endpoint: http://localhost:8090 (internal: http://$ip:8080)"
        fi
    else
        log_warning "Connect Server containers are not running"
    fi
}

health_check() {
    local quiet=false
    if [[ "${1:-}" == "--quiet" ]]; then
        quiet=true
    fi
    
    if [[ "$quiet" != "true" ]]; then
        log_info "üè• Performing Connect Server health checks..."
    fi
    
    local all_healthy=true
    
    # Check if containers are running
    local api_container=$(docker compose -f "$CONNECT_COMPOSE_FILE" ps -q onepassword-connect-api 2>/dev/null || true)
    local sync_container=$(docker compose -f "$CONNECT_COMPOSE_FILE" ps -q onepassword-connect-sync 2>/dev/null || true)
    
    if [[ -z "$api_container" ]] || [[ -z "$sync_container" ]]; then
        if [[ "$quiet" != "true" ]]; then
            log_error "Connect Server containers are not running"
        fi
        return 1
    fi
    
    # Check container health status
    local api_health=$(docker inspect "$api_container" --format '{{.State.Health.Status}}' 2>/dev/null || echo "no_healthcheck")
    local sync_health=$(docker inspect "$sync_container" --format '{{.State.Health.Status}}' 2>/dev/null || echo "no_healthcheck")
    
    if [[ "$api_health" != "healthy" ]]; then
        if [[ "$quiet" != "true" ]]; then
            log_error "API container health check failed: $api_health"
        fi
        all_healthy=false
    fi
    
    if [[ "$sync_health" != "healthy" ]]; then
        if [[ "$quiet" != "true" ]]; then
            log_error "Sync container health check failed: $sync_health"
        fi
        all_healthy=false
    fi
    
    # Test API endpoint
    if curl -f -s "http://localhost:8090/health" > /dev/null; then
        if [[ "$quiet" != "true" ]]; then
            log_success "‚úÖ API endpoint is responding"
        fi
    else
        if [[ "$quiet" != "true" ]]; then
            log_error "‚ùå API endpoint is not responding"
        fi
        all_healthy=false
    fi
    
    if [[ "$all_healthy" == "true" ]]; then
        if [[ "$quiet" != "true" ]]; then
            log_success "üéâ All health checks passed!"
        fi
        return 0
    else
        return 1
    fi
}

show_logs() {
    local follow=false
    
    # Parse options
    while [[ $# -gt 0 ]]; do
        case $1 in
            -f|--follow)
                follow=true
                shift
                ;;
            *)
                log_error "Unknown option: $1"
                exit 1
                ;;
        esac
    done
    
    cd "$PROJECT_ROOT"
    
    if [[ "$follow" == "true" ]]; then
        log_info "üìã Following Connect Server logs (Ctrl+C to exit)..."
        docker compose -f "$CONNECT_COMPOSE_FILE" logs -f
    else
        log_info "üìã Connect Server logs (last 50 lines)..."
        docker compose -f "$CONNECT_COMPOSE_FILE" logs --tail 50
    fi
}

manage_token() {
    local action="${1:-}"
    
    case "$action" in
        "create"|"generate")
            log_info "üîë Generating new Connect Server access token..."
            if command -v op &> /dev/null; then
                op connect token create "Athena-Core-$(date +%Y%m%d-%H%M%S)" --server "Athena Core Connect Server" --vault "API"
            else
                log_error "1Password CLI (op) is required for token management"
                exit 1
            fi
            ;;
        "list")
            log_info "üìã Listing Connect Server tokens..."
            if command -v op &> /dev/null; then
                op connect token list --server "Athena Core Connect Server"
            else
                log_error "1Password CLI (op) is required for token management"
                exit 1
            fi
            ;;
        *)
            log_error "Token action required: create|generate|list"
            exit 1
            ;;
    esac
}

test_api() {
    log_info "üß™ Testing Connect Server API connectivity..."
    
    # First check if server is running
    if ! health_check --quiet; then
        log_error "Connect Server is not healthy. Start with: $0 start"
        exit 1
    fi
    
    # Test basic endpoints without authentication (should fail gracefully)
    log_info "Testing health endpoint..."
    if curl -f -s "http://localhost:8090/health" > /dev/null; then
        log_success "‚úÖ Health endpoint responding"
    else
        log_error "‚ùå Health endpoint not responding"
    fi
    
    log_info "Testing API endpoint (should require authentication)..."
    local response=$(curl -s -o /dev/null -w "%{http_code}" "http://localhost:8090/v1/vaults" || echo "000")
    
    if [[ "$response" == "401" ]]; then
        log_success "‚úÖ API endpoint properly requiring authentication"
        log_info "Generate access token with: $0 token create"
    elif [[ "$response" == "200" ]]; then
        log_warning "‚ö†Ô∏è  API endpoint responding without authentication (check configuration)"
    else
        log_error "‚ùå Unexpected API response code: $response"
    fi
}

cleanup_connect_server() {
    log_warning "üßπ This will remove Connect Server containers and cached data"
    read -p "Are you sure? [y/N] " -n 1 -r
    echo
    
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        log_info "Cleaning up Connect Server..."
        cd "$PROJECT_ROOT"
        
        # Stop and remove containers
        docker compose -f "$CONNECT_COMPOSE_FILE" down -v
        
        # Remove any dangling images
        docker image prune -f --filter label=com.${COMPOSE_PROJECT_NAME}.service
        
        log_success "Connect Server cleanup completed"
    else
        log_info "Cleanup cancelled"
    fi
}

main() {
    local command="${1:-}"
    shift 2>/dev/null || true
    
    case "$command" in
        "start")
            check_prerequisites
            start_connect_server
            ;;
        "stop")
            stop_connect_server
            ;;
        "restart")
            check_prerequisites
            restart_connect_server
            ;;
        "status")
            show_status
            ;;
        "health")
            health_check
            ;;
        "logs")
            show_logs "$@"
            ;;
        "token")
            manage_token "$@"
            ;;
        "test")
            test_api
            ;;
        "cleanup")
            cleanup_connect_server
            ;;
        "help"|"--help"|"-h"|"")
            show_usage
            ;;
        *)
            log_error "Unknown command: $command"
            show_usage
            exit 1
            ;;
    esac
}

# Only run main if script is executed directly (not sourced)
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi