#!/bin/bash

# connect-api.sh
# REST API client library for 1Password Connect Server
# Provides functions for secure secret retrieval via HTTP API

set -euo pipefail

# Default configuration
CONNECT_API_URL="${CONNECT_API_URL:-http://localhost:8090}"
CONNECT_TOKEN_FILE="${CONNECT_TOKEN_FILE:-}"
CONNECT_TOKEN="${CONNECT_TOKEN:-}"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

log_info() {
    echo -e "${BLUE}[API]${NC} $1" >&2
}

log_success() {
    echo -e "${GREEN}[API]${NC} $1" >&2
}

log_warning() {
    echo -e "${YELLOW}[API]${NC} $1" >&2
}

log_error() {
    echo -e "${RED}[API]${NC} $1" >&2
}

show_usage() {
    cat << EOF
Usage: $0 <command> [options]

COMMANDS:
    health                      Check Connect Server health
    list-vaults                 List available vaults
    list-items <vault_id>       List items in a vault
    get-item <vault_id> <item_id>   Get item details
    get-field <vault_id> <item_id> <field>   Get specific field value
    search <query>              Search for items
    inject-template <template_file> <output_file>   Process template file

ENVIRONMENT VARIABLES:
    CONNECT_API_URL            Connect Server URL (default: http://localhost:8090)
    CONNECT_TOKEN              Access token for authentication
    CONNECT_TOKEN_FILE         File containing access token

EXAMPLES:
    $0 health                                    # Check server health
    $0 list-vaults                              # List all vaults
    $0 list-items cgwl5xkislwmyperyset36nhuy    # List items in API vault
    $0 get-field cgwl5xkislwmyperyset36nhuy item_id credential
    $0 inject-template .env.template .env       # Process template file

AUTHENTICATION:
    Set CONNECT_TOKEN environment variable or CONNECT_TOKEN_FILE path.
    Generate tokens with: ./scripts/manage-connect-server.sh token create

EOF
}

get_auth_token() {
    if [[ -n "$CONNECT_TOKEN" ]]; then
        echo "$CONNECT_TOKEN"
    elif [[ -n "$CONNECT_TOKEN_FILE" && -f "$CONNECT_TOKEN_FILE" ]]; then
        cat "$CONNECT_TOKEN_FILE"
    else
        log_error "No authentication token configured"
        log_error "Set CONNECT_TOKEN environment variable or CONNECT_TOKEN_FILE path"
        log_error "Generate token with: ./scripts/manage-connect-server.sh token create"
        exit 1
    fi
}

make_api_request() {
    local method="$1"
    local endpoint="$2"
    local data="${3:-}"
    local token=$(get_auth_token)
    
    local curl_args=(
        -s
        -X "$method"
        -H "Authorization: Bearer $token"
        -H "Content-Type: application/json"
        -H "Accept: application/json"
    )
    
    if [[ -n "$data" ]]; then
        curl_args+=(-d "$data")
    fi
    
    # Make the request and capture both response and HTTP status
    local response=$(curl "${curl_args[@]}" -w "\n%{http_code}" "$CONNECT_API_URL$endpoint" 2>/dev/null)
    local http_code=$(echo "$response" | tail -n1)
    local body=$(echo "$response" | head -n -1)
    
    case "$http_code" in
        200|201)
            echo "$body"
            return 0
            ;;
        401)
            log_error "Authentication failed. Check your access token."
            return 1
            ;;
        403)
            log_error "Access denied. Check vault permissions for your token."
            return 1
            ;;
        404)
            log_error "Resource not found: $endpoint"
            return 1
            ;;
        *)
            log_error "API request failed with HTTP $http_code"
            if [[ -n "$body" ]]; then
                log_error "Response: $body"
            fi
            return 1
            ;;
    esac
}

check_health() {
    log_info "Checking Connect Server health..."
    
    # Health endpoint doesn't require authentication
    local response=$(curl -s -f "$CONNECT_API_URL/health" 2>/dev/null || echo "")
    
    if [[ -n "$response" ]]; then
        log_success "✅ Connect Server is healthy"
        echo "$response"
        return 0
    else
        log_error "❌ Connect Server health check failed"
        return 1
    fi
}

list_vaults() {
    log_info "Listing available vaults..."
    
    local response=$(make_api_request "GET" "/v1/vaults")
    if [[ $? -eq 0 ]]; then
        # Pretty print vault information
        echo "$response" | jq -r '.[] | "\(.id)\t\(.name)"' 2>/dev/null || {
            log_warning "jq not available, showing raw response:"
            echo "$response"
        }
    fi
}

list_items() {
    local vault_id="$1"
    
    if [[ -z "$vault_id" ]]; then
        log_error "Vault ID is required"
        return 1
    fi
    
    log_info "Listing items in vault: $vault_id"
    
    local response=$(make_api_request "GET" "/v1/vaults/$vault_id/items")
    if [[ $? -eq 0 ]]; then
        # Pretty print item information
        echo "$response" | jq -r '.[] | "\(.id)\t\(.title)"' 2>/dev/null || {
            log_warning "jq not available, showing raw response:"
            echo "$response"
        }
    fi
}

get_item() {
    local vault_id="$1"
    local item_id="$2"
    
    if [[ -z "$vault_id" || -z "$item_id" ]]; then
        log_error "Vault ID and Item ID are required"
        return 1
    fi
    
    log_info "Getting item: $item_id from vault: $vault_id"
    
    local response=$(make_api_request "GET" "/v1/vaults/$vault_id/items/$item_id")
    if [[ $? -eq 0 ]]; then
        echo "$response"
    fi
}

get_field() {
    local vault_id="$1"
    local item_id="$2"
    local field_name="$3"
    
    if [[ -z "$vault_id" || -z "$item_id" || -z "$field_name" ]]; then
        log_error "Vault ID, Item ID, and field name are required"
        return 1
    fi
    
    log_info "Getting field '$field_name' from item: $item_id"
    
    local response=$(make_api_request "GET" "/v1/vaults/$vault_id/items/$item_id")
    if [[ $? -eq 0 ]]; then
        # Extract field value using jq
        local field_value=$(echo "$response" | jq -r ".fields[] | select(.label==\"$field_name\") | .value" 2>/dev/null)
        
        if [[ -n "$field_value" && "$field_value" != "null" ]]; then
            echo "$field_value"
        else
            # Try by field ID if label doesn't match
            field_value=$(echo "$response" | jq -r ".fields[] | select(.id==\"$field_name\") | .value" 2>/dev/null)
            
            if [[ -n "$field_value" && "$field_value" != "null" ]]; then
                echo "$field_value"
            else
                log_error "Field '$field_name' not found in item"
                return 1
            fi
        fi
    fi
}

search_items() {
    local query="$1"
    
    if [[ -z "$query" ]]; then
        log_error "Search query is required"
        return 1
    fi
    
    log_info "Searching for: $query"
    
    # Search across all accessible vaults
    local vaults=$(make_api_request "GET" "/v1/vaults" | jq -r '.[].id' 2>/dev/null)
    
    for vault_id in $vaults; do
        local items=$(make_api_request "GET" "/v1/vaults/$vault_id/items")
        local matches=$(echo "$items" | jq -r ".[] | select(.title | test(\"$query\"; \"i\")) | \"\(.id)\t\(.title)\t$vault_id\"" 2>/dev/null)
        
        if [[ -n "$matches" ]]; then
            echo "$matches"
        fi
    done
}

inject_template() {
    local template_file="$1"
    local output_file="$2"
    
    if [[ -z "$template_file" || -z "$output_file" ]]; then
        log_error "Template file and output file are required"
        return 1
    fi
    
    if [[ ! -f "$template_file" ]]; then
        log_error "Template file not found: $template_file"
        return 1
    fi
    
    log_info "Processing template: $template_file -> $output_file"
    
    # Read template file
    local template_content=$(cat "$template_file")
    local processed_content="$template_content"
    
    # Find all 1Password references in format: {{ op://vault/item/field }}
    local op_refs=$(echo "$template_content" | grep -oE '\{\{\s*op://[^}]+\s*\}\}')
    
    while IFS= read -r op_ref; do
        if [[ -n "$op_ref" ]]; then
            # Parse the reference: {{ op://vault/item/field }}
            local ref_path=$(echo "$op_ref" | sed 's/{{[[:space:]]*op:\/\/\([^}]*\)[[:space:]]*}}/\1/')
            local vault_name=$(echo "$ref_path" | cut -d'/' -f1)
            local item_name=$(echo "$ref_path" | cut -d'/' -f2)
            local field_name=$(echo "$ref_path" | cut -d'/' -f3)
            
            log_info "Resolving: $vault_name/$item_name/$field_name"
            
            # Find vault ID by name
            local vault_id=$(make_api_request "GET" "/v1/vaults" | jq -r ".[] | select(.name==\"$vault_name\") | .id" 2>/dev/null)
            
            if [[ -z "$vault_id" || "$vault_id" == "null" ]]; then
                log_error "Vault '$vault_name' not found"
                return 1
            fi
            
            # Find item ID by title
            local item_id=$(make_api_request "GET" "/v1/vaults/$vault_id/items" | jq -r ".[] | select(.title==\"$item_name\") | .id" 2>/dev/null)
            
            if [[ -z "$item_id" || "$item_id" == "null" ]]; then
                log_error "Item '$item_name' not found in vault '$vault_name'"
                return 1
            fi
            
            # Get field value
            local field_value=$(get_field "$vault_id" "$item_id" "$field_name")
            
            if [[ $? -eq 0 && -n "$field_value" ]]; then
                # Replace the reference with the actual value
                processed_content=$(echo "$processed_content" | sed "s|$(echo "$op_ref" | sed 's/[[\.*^$()+?{|]/\\&/g')|$field_value|g")
            else
                log_error "Failed to resolve: $op_ref"
                return 1
            fi
        fi
    done <<< "$op_refs"
    
    # Write processed content to output file
    echo "$processed_content" > "$output_file"
    
    # Set secure permissions
    chmod 600 "$output_file"
    
    log_success "Template processed successfully: $output_file"
}

# Function to resolve a single 1Password reference
resolve_op_reference() {
    local op_ref="$1"
    
    # Parse the reference: op://vault/item/field
    local ref_path=$(echo "$op_ref" | sed 's/op:\/\/\(.*\)/\1/')
    local vault_name=$(echo "$ref_path" | cut -d'/' -f1)
    local item_name=$(echo "$ref_path" | cut -d'/' -f2)
    local field_name=$(echo "$ref_path" | cut -d'/' -f3)
    
    # Find vault ID by name
    local vault_id=$(make_api_request "GET" "/v1/vaults" | jq -r ".[] | select(.name==\"$vault_name\") | .id" 2>/dev/null)
    
    if [[ -z "$vault_id" || "$vault_id" == "null" ]]; then
        log_error "Vault '$vault_name' not found" >&2
        return 1
    fi
    
    # Find item ID by title
    local item_id=$(make_api_request "GET" "/v1/vaults/$vault_id/items" | jq -r ".[] | select(.title==\"$item_name\") | .id" 2>/dev/null)
    
    if [[ -z "$item_id" || "$item_id" == "null" ]]; then
        log_error "Item '$item_name' not found in vault '$vault_name'" >&2
        return 1
    fi
    
    # Get field value
    get_field "$vault_id" "$item_id" "$field_name"
}

main() {
    local command="${1:-}"
    shift 2>/dev/null || true
    
    case "$command" in
        "health")
            check_health
            ;;
        "list-vaults")
            list_vaults
            ;;
        "list-items")
            list_items "$@"
            ;;
        "get-item")
            get_item "$@"
            ;;
        "get-field")
            get_field "$@"
            ;;
        "search")
            search_items "$@"
            ;;
        "inject-template")
            inject_template "$@"
            ;;
        "resolve")
            resolve_op_reference "$@"
            ;;
        "help"|"--help"|"-h"|"")
            show_usage
            ;;
        *)
            log_error "Unknown command: $command"
            show_usage
            exit 1
            ;;
    esac
}

# Only run main if script is executed directly (not sourced)
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi